# 算法导论
## 第一章-简介
## 第二章-算法基础
### 2.1-插入排序（算法基础-引子）
1. idea(算法思想)
```
循环获取数据key，然后在该数据key之前找到合适位置（规定的排序条件）后再插入，实现了插入时即排序的效果
```
2. fake-code(伪代码)
```
算法导论版:
INSERTION-SORT(A) // 定义该函数名称A-待排数组
for j = 2 to A.length // j从2直到A的末尾
    key = A[j] // 取出待排数
    // 插入数据到已经排过序的A[1,j - 1]
    i = j - 1; // 定义从key的前一个位置到start位置扫描A的开始位置-该部分已经排序过，只需要后移元素那些大于key的元素即可
    while i > 0 and A[i] > key // 将大于当前待排key值的后移
      A[i+1] = A[i]
      i = i - 1
    A[i + 1] = key;
```
3. analysis(对该算法的分析)
    - 时间复杂度（忽略循环中常数部分）：
      - 最好情况：该数组已排序，每次只需要取出key，无需进行元素后移，该情况为O(n)
      - 最坏情况：该数组为逆置数组，取出key消耗n-1次，因为是逆置所以前面的数全部要后移，每次取数的key为数组中的j的位置的话-那么每次要前移j-1个数据，所以共有 1+2+3+···+n-1 次前移操作，所以该部分时间复杂度为O(n<sup>2</sup>)
4. x-code(具体实现代码x-为使用语言)
```
```
5. note（该部分笔记）
### 2.2-分析算法
### 2.3-设计算法
#### 2.3.1-分治法
    - 将问题分解为几个规模较小但类似原问题的若干子问题，递归地求解这些子问题，然后再合并这些子问题的解，来建立原问题的解
    - 典型例子-归并排序（这里不讨论-留在排序内容中讨论归并排序）
#### 2.3.2-分治分析算法
##### 这里主要是对算法的效率等进行研究
## 第三章-函数的增长
### 这里不讨论-基本只是在高等数学全部存在
## 第四章-分治策略
- 递归式
    递归式与分治方法是紧密相关的，因为使用递归式可以很自然的刻画分治算法的运行时间。一个递归式就是一个等式或者不等式（详情参见高等数学）
    - 介绍三个求解递归式的方法：
       - 代入法：我们猜测一个界，然后用数学归纳法证明这个界是正确的。
       - 递归树法：将递归式转换为一棵树，其结点表示不同层次的递归调用产生的代价。然后采用边界和技术来求解递归式。
       - 主方法：可求解形如下面公式的递归式的边界：
                  T(n) = aT(n/b) + f(n)
                其中a >= 1, b > 1, f(n)是一个给定的函数。这种形式的递归式很常见，它刻画了这样一个分治算法：生成a个子问题，每个子问题的规模是原问题